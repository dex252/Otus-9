1.  Принцип единственной ответственности
  - Разделил классы все классы по назначению в меру своих способностей, вышло следующее
```
   SettingsAggregator выполняет только задачу по получению настроек для их дальнейшего использования
   IReader читает настройки из файла(в данной реализаций), в последствии можно заменить на чтение из  других источников (бд, http и т.д.)
   IDeserialization отвечает за преобразование результата IReader в объект настроек, в нашей реализации преобразует текст формата json в модель данных. При необходимости может быть заменен на xml десериализатор или любой другой
   IRulesBuilder предназначен только для формирования игровых правил по заданным настройкам
   IRulesAggregate предназначен для получения списка сформированных правил для начала игры
   IRulesValidator предназначен для проверки игровых правил на корректность в любых игровых ситуациях во избежание ошибок перед игрой по заданным настройкам. В проекте есть единственная его реализация в виде AnyRuleValidator, проверяющим наличие хотя бы одного игрового правила на каждую игровую ситуацию
   INumberGenerator предназначен для задания числа, которое загадал компьютер. Сейчас - это случайно число, в дальнейшем можно будет заменить на иную логику формирования числа
   IGameBuilder предназначен для заполнения и формирования игровых правил с помощью INumberGenerator, IRuleDefinition
   IRuleDefinition содержит в себе функцию возврата набора правил, сформированных и провалидированных с помощью IRulesAggregate, IRulesValidator
   IGameProcess содержит в себе основную игровую логику в методах NextAction, IsFinishGame, формирование начальных игровых настроек в конструкторе
   GameRunner не имеет интерфейса. Содержит единственный метод Run, отвечающий за начало игры
```
   
2.  Принцип инверсии зависимостей
  - Почти все компоненты разбиты на абстракции, и не зависят от деталей. Детали зависят от абстракций, например
  ```
  IGameRule описывает игровое правило, которое строится в зависимости от переданных в него абстракций в виде двух функций и приоритета выполнения операций
  ```
3.  Принцип разделения интерфейса
  - Классы зависят только от тех интерфейсов, которые используют. На примере:
  ```
  GameRules включает в себя 2 интерфейса IGamesRules и IGameRulesFillable. IGamesRules наследуется от IGameRulesGettable, единственная задача которого - Получить игровые правила, удовлетворяющие условиям текущего игрового процесса. В тоже время IGameRulesFillable используется для добавления игровых правил в этот класс для последующего использования. Оба интерфейса используются в проекте по мере необходимости, но не оба разом, так как преследуют разные задачи
  ```
4.  Принцип открытости/закрытости
  - При изменении условий задачи модификация существующих объектов не требуется, достаточно расширить их путем наследования или добавлением новых абстракций, например:
  ```
  При добавлении в проект нового игрового правила со своей собственной логикой достаточно добавить новую реализацию абстракции IRuleSetter в проект, либо унаследоваться от одной из существующих его реализаций
  ```
5.  Принцип подстановки Барбары Лисков
  - Все функции используют объекты производных от базового классов, не зная о деталях реализации этих классов, например:
  ```
  IGameProcess в методе NextAction использует метод Execute абстракции IGameRule. Игровой процесс ничего не знает об объектах и методах, используемых в функции Execute, которая под капотом использует методы абтсракций игровых правил IRuleSetter, которые в свою очередь могут использовать (а могут и не использовать) текущие игровые настройки.
  ```
